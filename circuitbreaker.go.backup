package pipz

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/zoobzio/clockz"
	"github.com/zoobzio/hookz"
	"github.com/zoobzio/metricz"
	"github.com/zoobzio/tracez"
)

// Observability constants for the CircuitBreaker connector.
const (
	// Metrics.
	CircuitBreakerProcessedTotal   = metricz.Key("circuitbreaker.processed.total")
	CircuitBreakerSuccessesTotal   = metricz.Key("circuitbreaker.successes.total")
	CircuitBreakerFailuresTotal    = metricz.Key("circuitbreaker.failures.total")
	CircuitBreakerOpenedTotal      = metricz.Key("circuitbreaker.opened.total")
	CircuitBreakerRejectedTotal    = metricz.Key("circuitbreaker.rejected.total")
	CircuitBreakerStateTransitions = metricz.Key("circuitbreaker.state.transitions")
	CircuitBreakerCurrentState     = metricz.Key("circuitbreaker.state.current")
	CircuitBreakerConsecutiveFails = metricz.Key("circuitbreaker.consecutive.failures")

	// Spans.
	CircuitBreakerProcessSpan = tracez.Key("circuitbreaker.process")

	// Tags.
	CircuitBreakerTagState       = tracez.Tag("circuitbreaker.state")
	CircuitBreakerTagAllowed     = tracez.Tag("circuitbreaker.allowed")
	CircuitBreakerTagStateChange = tracez.Tag("circuitbreaker.state_change")
	CircuitBreakerTagError       = tracez.Tag("circuitbreaker.error")

	// State constants
	stateClosed   = "closed"
	stateOpen     = "open"
	stateHalfOpen = "half-open"

	// Hook event keys.
	CircuitBreakerEventOpened   = hookz.Key("circuitbreaker.opened")
	CircuitBreakerEventClosed   = hookz.Key("circuitbreaker.closed")
	CircuitBreakerEventHalfOpen = hookz.Key("circuitbreaker.halfopen")
	CircuitBreakerEventRejected = hookz.Key("circuitbreaker.rejected")
)

// CircuitBreakerStateChange represents a state transition event.
// This is emitted via hookz when the circuit breaker changes state,
// allowing external systems to react to circuit state changes.
type CircuitBreakerStateChange struct {
	Name                Name      // Connector name
	OldState            string    // Previous state
	NewState            string    // New state
	ConsecutiveFailures int       // Current failure count
	Reason              string    // Why the state changed
	Timestamp           time.Time // When it occurred
}

// CircuitBreaker prevents cascading failures by stopping requests to failing services.
// CircuitBreaker implements the circuit breaker pattern with three states:
//   - Closed: Normal operation, requests pass through
//   - Open: Requests fail immediately without calling the wrapped processor
//   - Half-Open: Testing state, limited requests to check if service recovered
//
// CRITICAL: CircuitBreaker is a STATEFUL connector that tracks failure counts across requests.
// You MUST create it as a package-level variable (singleton) to maintain state.
// Creating a new CircuitBreaker for each request means it will NEVER open!
//
// ❌ WRONG - Creating per request (never opens):
//
//	func handleRequest(req Request) Response {
//	    breaker := pipz.NewCircuitBreaker("api", proc, 5, 30*time.Second)  // NEW breaker!
//	    return breaker.Process(ctx, req)  // Always closed, failure count always 0
//	}
//
// ✅ RIGHT - Package-level singleton:
//
//	var apiBreaker = pipz.NewCircuitBreaker("api", apiProcessor, 5, 30*time.Second)
//
//	func handleRequest(req Request) Response {
//	    return apiBreaker.Process(ctx, req)  // Tracks failures across requests
//	}
//
// The circuit opens after consecutive failures reach the threshold. After a
// timeout period, it transitions to half-open to test recovery. Successful
// requests in half-open state close the circuit, while failures reopen it.
//
// CircuitBreaker is essential for:
//   - Preventing cascade failures in distributed systems
//   - Giving failing services time to recover
//   - Failing fast when services are down
//   - Reducing unnecessary load on struggling services
//   - Improving overall system resilience
//
// Best Practices:
//   - Use const names for all processors/connectors (see best-practices.md)
//   - Declare CircuitBreakers as package-level vars
//   - Set thresholds based on service characteristics
//   - Combine with RateLimiter for comprehensive protection
//   - Monitor circuit state for operational awareness
//
// Example:
//
//	// Define names as constants
//	const (
//	    ConnectorAPIBreaker      = "api-breaker"
//	    ConnectorDatabaseBreaker = "db-breaker"
//	    ProcessorAPICall         = "api-call"
//	)
//
//	// Create breakers as package-level singletons
//	var (
//	    // External API - fail fast, longer recovery
//	    apiBreaker = pipz.NewCircuitBreaker(
//	        ConnectorAPIBreaker,
//	        pipz.Apply(ProcessorAPICall, callExternalAPI),
//	        5,                    // Open after 5 failures
//	        30 * time.Second,     // Try recovery after 30s
//	    )
//
//	    // Internal database - more tolerant
//	    dbBreaker = pipz.NewCircuitBreaker(
//	        ConnectorDatabaseBreaker,
//	        pipz.Apply("db-query", queryDatabase),
//	        10,                   // Open after 10 failures
//	        10 * time.Second,     // Try recovery after 10s
//	    )
//	)
//
//	// Combine with rate limiting for full protection
//	func createResilientPipeline() pipz.Chainable[Request] {
//	    return pipz.NewSequence("resilient-pipeline",
//	        rateLimiter,    // Protect downstream from overload
//	        apiBreaker,     // Fail fast if service is down
//	        pipz.NewRetry("retry", processor, 3),  // Retry transient failures
//	    )
//	}
//
// # Observability
//
// CircuitBreaker provides comprehensive observability through metrics, tracing, and events:
//
// Metrics:
//   - circuitbreaker.requests.total: Counter of total requests processed
//   - circuitbreaker.failures.total: Counter of consecutive failures
//   - circuitbreaker.successes.total: Counter of successful requests
//   - circuitbreaker.rejections.total: Counter of requests rejected (open state)
//   - circuitbreaker.state: Gauge showing current state (0=closed, 1=open, 2=half-open)
//
// Traces:
//   - circuitbreaker.process: Span for circuit breaker processing
//   - Tags include state, success status, and rejection reason
//
// Events (via hooks):
//   - circuitbreaker.opened: Fired when circuit opens due to failures
//   - circuitbreaker.closed: Fired when circuit closes after recovery
//   - circuitbreaker.halfopen: Fired when circuit enters testing state
//   - circuitbreaker.rejected: Fired when requests are rejected (open state)
//
// Example with hooks:
//
//	var apiBreaker = pipz.NewCircuitBreaker(
//	    "api-breaker",
//	    apiProcessor,
//	    5,
//	    30*time.Second,
//	)
//
//	// Alert when circuit opens
//	apiBreaker.OnOpened(func(ctx context.Context, event CircuitBreakerStateChange) error {
//	    alert.Send("API circuit breaker opened after %d failures", event.FailureCount)
//	    return nil
//	})
//
//	// Log recovery
//	apiBreaker.OnClosed(func(ctx context.Context, event CircuitBreakerStateChange) error {
//	    log.Info("Circuit recovered from %s state", event.OldState)
//	    return nil
//	})
type CircuitBreaker[T any] struct {
	lastFailTime     time.Time
	processor        Chainable[T]
	clock            clockz.Clock
	name             Name
	state            string
	mu               sync.Mutex
	resetTimeout     time.Duration
	generation       uint64
	failureThreshold int
	successThreshold int
	failures         int
	successes        int
	metrics          *metricz.Registry
	tracer           *tracez.Tracer
	hooks            *hookz.Hooks[CircuitBreakerStateChange]
}

// NewCircuitBreaker creates a new CircuitBreaker connector.
// The failureThreshold sets how many consecutive failures trigger opening.
// The resetTimeout sets how long to wait before attempting recovery.
func NewCircuitBreaker[T any](name Name, processor Chainable[T], failureThreshold int, resetTimeout time.Duration) *CircuitBreaker[T] {
	if failureThreshold < 1 {
		failureThreshold = 1
	}

	// Initialize observability
	metrics := metricz.New()
	metrics.Counter(CircuitBreakerProcessedTotal)
	metrics.Counter(CircuitBreakerSuccessesTotal)
	metrics.Counter(CircuitBreakerFailuresTotal)
	metrics.Counter(CircuitBreakerOpenedTotal)
	metrics.Counter(CircuitBreakerRejectedTotal)
	metrics.Counter(CircuitBreakerStateTransitions)
	metrics.Gauge(CircuitBreakerCurrentState)
	metrics.Gauge(CircuitBreakerConsecutiveFails)

	cb := &CircuitBreaker[T]{
		name:             name,
		processor:        processor,
		failureThreshold: failureThreshold,
		successThreshold: 1, // Default: 1 success to close from half-open
		resetTimeout:     resetTimeout,
		state:            stateClosed,
		metrics:          metrics,
		tracer:           tracez.New(),
		hooks:            hookz.New[CircuitBreakerStateChange](),
	}

	// Set initial state gauge (0 = closed, 1 = open, 2 = half-open)
	cb.metrics.Gauge(CircuitBreakerCurrentState).Set(0)

	return cb
}

// Process implements the Chainable interface.
func (cb *CircuitBreaker[T]) Process(ctx context.Context, data T) (result T, err error) {
	defer recoverFromPanic(&result, &err, cb.name, data)

	// Track metrics
	cb.metrics.Counter(CircuitBreakerProcessedTotal).Inc()

	// Start span
	ctx, span := cb.tracer.StartSpan(ctx, CircuitBreakerProcessSpan)
	defer func() {
		if err != nil {
			span.SetTag(CircuitBreakerTagError, err.Error())
		}
		span.Finish()
	}()

	cb.mu.Lock()

	// Check if we should transition from open to half-open
	clock := cb.getClock()
	if cb.state == stateOpen && clock.Since(cb.lastFailTime) > cb.resetTimeout {
		oldState := cb.state
		cb.state = stateHalfOpen
		cb.failures = 0
		cb.successes = 0
		cb.generation++
		cb.metrics.Counter(CircuitBreakerStateTransitions).Inc()
		cb.metrics.Gauge(CircuitBreakerCurrentState).Set(2) // half-open = 2
		span.SetTag(CircuitBreakerTagStateChange, fmt.Sprintf("%s->%s", oldState, cb.state))

		// Emit hook event
		_ = cb.hooks.Emit(ctx, CircuitBreakerEventHalfOpen, CircuitBreakerStateChange{
			Name:                cb.name,
			OldState:            oldState,
			NewState:            stateHalfOpen,
			ConsecutiveFailures: 0,
			Reason:              "timeout_elapsed",
			Timestamp:           clock.Now(),
		})
	}

	state := cb.state
	generation := cb.generation
	processor := cb.processor
	span.SetTag(CircuitBreakerTagState, state)

	// Fail fast if circuit is open
	if state == stateOpen {
		cb.metrics.Counter(CircuitBreakerRejectedTotal).Inc()
		span.SetTag(CircuitBreakerTagAllowed, "false")

		// Emit hook event for rejection
		cb.hooks.Emit(ctx, //nolint:errcheck CircuitBreakerEventRejected, CircuitBreakerStateChange{
			Name:                cb.name,
			OldState:            state,
			NewState:            state,
			ConsecutiveFailures: cb.failures,
			Reason:              "circuit_open",
			Timestamp:           cb.getClock().Now(),
		})

		cb.mu.Unlock()
		return data, &Error[T]{
			Err:       fmt.Errorf("circuit breaker is open"),
			InputData: data,
			Path:      []Name{cb.name},
			Timestamp: cb.getClock().Now(),
		}
	}

	span.SetTag(CircuitBreakerTagAllowed, "true")
	cb.mu.Unlock()

	// Try the operation
	result, err = processor.Process(ctx, data)

	// Record the result
	cb.mu.Lock()
	defer cb.mu.Unlock()

	// Only update state if we're still in the same generation
	// This prevents race conditions in half-open state
	if cb.generation != generation {
		return result, err
	}

	if err != nil {
		cb.onFailure(ctx)
		// Wrap the error with circuit breaker context
		var pipeErr *Error[T]
		if errors.As(err, &pipeErr) {
			pipeErr.Path = append([]Name{cb.name}, pipeErr.Path...)
			return result, pipeErr
		}
		return result, &Error[T]{
			Err:       err,
			InputData: data,
			Path:      []Name{cb.name},
			Timestamp: cb.getClock().Now(),
		}
	}

	cb.onSuccess(ctx)
	return result, nil
}

// onSuccess handles successful request.
func (cb *CircuitBreaker[T]) onSuccess(ctx context.Context) {
	cb.metrics.Counter(CircuitBreakerSuccessesTotal).Inc()

	switch cb.state {
	case stateClosed:
		// Reset failure count on success
		cb.failures = 0
		cb.metrics.Gauge(CircuitBreakerConsecutiveFails).Set(0)
	case stateHalfOpen:
		cb.successes++
		if cb.successes >= cb.successThreshold {
			oldState := cb.state
			// Enough successes, close the circuit
			cb.state = stateClosed
			cb.failures = 0
			cb.successes = 0
			cb.metrics.Counter(CircuitBreakerStateTransitions).Inc()
			cb.metrics.Gauge(CircuitBreakerCurrentState).Set(0) // closed = 0
			cb.metrics.Gauge(CircuitBreakerConsecutiveFails).Set(0)

			// Emit hook event
			cb.hooks.Emit(ctx, //nolint:errcheck CircuitBreakerEventClosed, CircuitBreakerStateChange{
				Name:                cb.name,
				OldState:            oldState,
				NewState:            stateClosed,
				ConsecutiveFailures: 0,
				Reason:              "recovery_successful",
				Timestamp:           cb.getClock().Now(),
			})
		}
	}
}

// onFailure handles failed request.
func (cb *CircuitBreaker[T]) onFailure(ctx context.Context) {
	cb.lastFailTime = cb.getClock().Now()
	cb.metrics.Counter(CircuitBreakerFailuresTotal).Inc()

	switch cb.state {
	case stateClosed:
		cb.failures++
		cb.metrics.Gauge(CircuitBreakerConsecutiveFails).Set(float64(cb.failures))
		if cb.failures >= cb.failureThreshold {
			oldState := cb.state
			// Too many failures, open the circuit
			cb.state = stateOpen
			cb.metrics.Counter(CircuitBreakerOpenedTotal).Inc()
			cb.metrics.Counter(CircuitBreakerStateTransitions).Inc()
			cb.metrics.Gauge(CircuitBreakerCurrentState).Set(1) // open = 1

			// Emit hook event
			cb.hooks.Emit(ctx, //nolint:errcheck CircuitBreakerEventOpened, CircuitBreakerStateChange{
				Name:                cb.name,
				OldState:            oldState,
				NewState:            stateOpen,
				ConsecutiveFailures: cb.failures,
				Reason:              "failure_threshold_exceeded",
				Timestamp:           cb.getClock().Now(),
			})
		}
	case stateHalfOpen:
		oldState := cb.state
		// Any failure in half-open state reopens the circuit
		cb.state = stateOpen
		cb.failures = 0
		cb.successes = 0
		cb.metrics.Counter(CircuitBreakerOpenedTotal).Inc()
		cb.metrics.Counter(CircuitBreakerStateTransitions).Inc()
		cb.metrics.Gauge(CircuitBreakerCurrentState).Set(1) // open = 1

		// Emit hook event
		cb.hooks.Emit(ctx, //nolint:errcheck CircuitBreakerEventOpened, CircuitBreakerStateChange{
			Name:                cb.name,
			OldState:            oldState,
			NewState:            stateOpen,
			ConsecutiveFailures: 1, // Single failure in half-open
			Reason:              "halfopen_test_failed",
			Timestamp:           cb.getClock().Now(),
		})
	}
}

// SetFailureThreshold updates the consecutive failures needed to open the circuit.
func (cb *CircuitBreaker[T]) SetFailureThreshold(n int) *CircuitBreaker[T] {
	if n < 1 {
		n = 1
	}
	cb.mu.Lock()
	defer cb.mu.Unlock()
	cb.failureThreshold = n
	return cb
}

// SetSuccessThreshold updates the successes needed to close from half-open state.
func (cb *CircuitBreaker[T]) SetSuccessThreshold(n int) *CircuitBreaker[T] {
	if n < 1 {
		n = 1
	}
	cb.mu.Lock()
	defer cb.mu.Unlock()
	cb.successThreshold = n
	return cb
}

// SetResetTimeout updates the time to wait before attempting recovery.
func (cb *CircuitBreaker[T]) SetResetTimeout(d time.Duration) *CircuitBreaker[T] {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	cb.resetTimeout = d
	return cb
}

// GetState returns the current circuit state.
func (cb *CircuitBreaker[T]) GetState() string {
	cb.mu.Lock()
	defer cb.mu.Unlock()

	// Check for automatic transition to half-open
	if cb.state == stateOpen && cb.getClock().Since(cb.lastFailTime) > cb.resetTimeout {
		return stateHalfOpen
	}

	return cb.state
}

// GetFailureThreshold returns the current failure threshold.
func (cb *CircuitBreaker[T]) GetFailureThreshold() int {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	return cb.failureThreshold
}

// GetSuccessThreshold returns the current success threshold.
func (cb *CircuitBreaker[T]) GetSuccessThreshold() int {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	return cb.successThreshold
}

// GetResetTimeout returns the current reset timeout.
func (cb *CircuitBreaker[T]) GetResetTimeout() time.Duration {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	return cb.resetTimeout
}

// Reset manually resets the circuit to closed state.
func (cb *CircuitBreaker[T]) Reset() *CircuitBreaker[T] {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	cb.state = stateClosed
	cb.failures = 0
	cb.successes = 0
	cb.generation++
	return cb
}

// WithClock sets a custom clock for testing.
func (cb *CircuitBreaker[T]) WithClock(clock clockz.Clock) *CircuitBreaker[T] {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	cb.clock = clock
	return cb
}

// getClock returns the clock to use.
func (cb *CircuitBreaker[T]) getClock() clockz.Clock {
	if cb.clock == nil {
		return clockz.RealClock
	}
	return cb.clock
}

// Name returns the name of this connector.
func (cb *CircuitBreaker[T]) Name() Name {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	return cb.name
}

// Metrics returns the metrics registry for this connector.
func (cb *CircuitBreaker[T]) Metrics() *metricz.Registry {
	return cb.metrics
}

// Tracer returns the tracer for this connector.
func (cb *CircuitBreaker[T]) Tracer() *tracez.Tracer {
	return cb.tracer
}

// Close gracefully shuts down observability components.
func (cb *CircuitBreaker[T]) Close() error {
	if cb.tracer != nil {
		cb.tracer.Close()
	}
	cb.hooks.Close()
	return nil
}

// OnOpened registers a handler for when the circuit opens.
// The handler is called asynchronously when the circuit breaker opens due to failures.
func (cb *CircuitBreaker[T]) OnOpened(handler func(context.Context, CircuitBreakerStateChange) error) error {
	_, err := cb.hooks.Hook(CircuitBreakerEventOpened, handler)
	return err
}

// OnClosed registers a handler for when the circuit closes.
// The handler is called asynchronously when the circuit breaker closes after recovery.
func (cb *CircuitBreaker[T]) OnClosed(handler func(context.Context, CircuitBreakerStateChange) error) error {
	_, err := cb.hooks.Hook(CircuitBreakerEventClosed, handler)
	return err
}

// OnHalfOpen registers a handler for when the circuit enters half-open state.
// The handler is called asynchronously when the circuit breaker starts testing recovery.
func (cb *CircuitBreaker[T]) OnHalfOpen(handler func(context.Context, CircuitBreakerStateChange) error) error {
	_, err := cb.hooks.Hook(CircuitBreakerEventHalfOpen, handler)
	return err
}

// OnRejected registers a handler for when the circuit rejects requests.
// The handler is called asynchronously when the circuit breaker rejects a request while open.
func (cb *CircuitBreaker[T]) OnRejected(handler func(context.Context, CircuitBreakerStateChange) error) error {
	_, err := cb.hooks.Hook(CircuitBreakerEventRejected, handler)
	return err
}
