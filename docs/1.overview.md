---
title: Overview
description: Type-safe, composable data pipelines for Go
author: zoobzio
published: 2025-12-13
updated: 2025-12-13
tags:
  - overview
  - introduction
---

# Overview

Data processing in Go often means choosing between type safety and flexibility.

pipz offers both: a single interface that everything implements, with zero reflection and full compile-time checking.

```go
type Chainable[T any] interface {
    Process(context.Context, T) (T, error)
    Name() Name
    Close() error
}
```

Implement it directly for custom processors. Use the provided wrappers for common patterns. Mix both approaches in the same pipeline.

```go
// Custom processor - full control
type RateLimiter[T any] struct {
    limiter *rate.Limiter
}

func (r *RateLimiter[T]) Process(ctx context.Context, data T) (T, error) {
    if err := r.limiter.Wait(ctx); err != nil {
        return data, err
    }
    return data, nil
}

// Built-in wrappers - convenience
validate := pipz.Apply("validate", validateOrder)
enrich := pipz.Transform("enrich", addTimestamp)

// Compose freely
pipeline := pipz.NewSequence("order-flow",
    validate,
    &RateLimiter[Order]{limiter: limiter},
    enrich,
)
```

Type-safe, minimal dependencies, panic-recovered by default.

## Philosophy

pipz draws inspiration from functional composition: small, focused units that combine into complex behaviors. Any type implementing `Chainable[T]` can participate in a pipeline. This creates a uniform abstraction that spans your entire processing flow.

```go
// Processors transform data
validate := pipz.Apply("validate", validatePayment)
charge := pipz.Apply("charge", chargeCard)

// Connectors compose processors
withRetry := pipz.NewRetry("retry", charge, 3)
withFallback := pipz.NewFallback("gateway", primaryCharge, backupCharge)
withTimeout := pipz.NewTimeout("bounded", pipeline, 5*time.Second)

// Everything composes the same way
robust := pipz.NewSequence("payment",
    validate,
    pipz.NewTimeout("charge-timeout",
        pipz.NewFallback("multi-gateway",
            pipz.NewRetry("primary", primaryCharge, 3),
            backupCharge,
        ),
        10*time.Second,
    ),
)
```

Three levels of composition, one interface, complete type safety throughout.

## Capabilities

A uniform interface opens possibilities:

**[Resilience](./4.cookbook/1.resilient-api-calls.md)** - Retry failed operations, fall back to alternatives, enforce timeouts. Layer these patterns without changing your processing logic.

**[Parallelism](./4.cookbook/5.bounded-parallelism.md)** - Run processors concurrently with `Concurrent`, bound parallelism with `WorkerPool`, race for first success with `Race`.

**[Routing](./3.guides/3.connector-selection.md)** - Direct data through different paths with `Switch`. Filter conditionally with `Filter`. Contest for the first result meeting criteria.

**[Observability](./2.learn/5.hooks.md)** - Emit typed signals on state changes. CircuitBreaker, RateLimiter, and WorkerPool broadcast their state for monitoring and alerting.

pipz provides the composition layer. What you build on top is up to you.

## Priorities

### Type Safety

Generics eliminate runtime type assertions. Data flows through pipelines with compile-time checking at every step.

```go
// Compile-time type checking
pipeline := pipz.NewSequence[Order]("process",
    pipz.Apply("validate", func(_ context.Context, o Order) (Order, error) {
        // o is Order, not interface{}
        return o, nil
    }),
)

// Type mismatch caught at compile time, not runtime
// pipeline.Process(ctx, "not an order") // Won't compile
```

### Composability

Small processors combine into complex behaviors. Each connector serves one purpose and combines cleanly with others.

```go
// Layer resilience patterns
resilient := pipz.NewTimeout("bounded",
    pipz.NewRetry("with-retry",
        pipz.NewFallback("with-fallback", primary, backup),
        3,
    ),
    5*time.Second,
)
```

No configuration objects. No builder patterns. Just composition.

### Error Context

Errors carry their full path through the pipeline. Know exactly where failures occurred, how long operations took, and what data was being processed.

```go
result, err := pipeline.Process(ctx, order)
if err != nil {
    var pipeErr *pipz.Error[Order]
    if errors.As(err, &pipeErr) {
        fmt.Printf("Failed at: %s\n", strings.Join(pipeErr.Path, " -> "))
        fmt.Printf("Duration: %v\n", pipeErr.Duration)
        fmt.Printf("Input: %+v\n", pipeErr.Input)
    }
}
// Output: Failed at: payment -> gateway -> primary
//         Duration: 2.3s
//         Input: Order{ID: "ORD-123", Total: 99.99}
```

### Errors as Data

Most frameworks treat errors as exceptions. pipz treats them as data that flows through pipelines. Build error recovery using the same tools you use for regular processing.

```go
// Error recovery pipeline - same patterns, same composition
errorHandler := pipz.NewSequence[*pipz.Error[Order]]("recover",
    pipz.Transform("categorize", categorizeError),
    pipz.NewSwitch("route", routeBySeverity),
)

// Attach to any pipeline
robust := pipz.NewHandle("order-flow", mainPipeline, errorHandler)
```

### Safety

Panics are recovered automatically with security-focused sanitization. One misbehaving processor won't crash your system or leak sensitive data in error messages.

```go
// Panics become errors, automatically
result, err := pipeline.Process(ctx, data)
// err contains sanitized panic info if a processor panicked
```
