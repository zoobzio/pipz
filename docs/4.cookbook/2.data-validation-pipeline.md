---
title: "Recipe: Data Validation Pipeline"
description: "Build comprehensive data validation with clear error messages and progressive enhancement"
author: zoobzio
published: 2025-12-13
updated: 2025-12-13
tags:
  - cookbook
  - validation
  - data-quality
  - error-handling
---

# Recipe: Data Validation Pipeline

Build comprehensive data validation with clear error messages and progressive enhancement.

## Problem

You need to validate complex data structures with:
- Multiple validation rules
- Clear error messages
- Optional enrichment
- Business rule enforcement
- Audit trails

## Solution

Create a layered validation pipeline:

```go
// Example: User registration validation
type User struct {
    Email     string
    Password  string
    Age       int
    Country   string
    Referrer  string
    Score     float64
}

// Define validation identities upfront
var (
    UserValidationID = pipz.NewIdentity("user-validation", "Validates user registration data")
    RequiredFieldsID = pipz.NewIdentity("required-fields", "Validates required fields are present")
    FormatValidationID = pipz.NewIdentity("format-validation", "Validates field formats and constraints")
    BusinessRulesID  = pipz.NewIdentity("business-rules", "Applies business-specific validation rules")
    UniquenessID     = pipz.NewIdentity("uniqueness", "Checks email uniqueness in database")
    RiskScoreID      = pipz.NewIdentity("risk-score", "Calculates user risk score")
    NormalizeID      = pipz.NewIdentity("normalize", "Normalizes field formats")
    AuditID          = pipz.NewIdentity("audit", "Logs validation event to audit trail")
)

func createUserValidationPipeline() pipz.Chainable[User] {
    return pipz.NewSequence[User](UserValidationID,
        // 1. Required field validation
        pipz.Apply(RequiredFieldsID, func(ctx context.Context, u User) (User, error) {
            if u.Email == "" {
                return u, errors.New("email is required")
            }
            if u.Password == "" {
                return u, errors.New("password is required")
            }
            if u.Age == 0 {
                return u, errors.New("age is required")
            }
            return u, nil
        }),

        // 2. Format validation
        pipz.Apply(FormatValidationID, func(ctx context.Context, u User) (User, error) {
            if !strings.Contains(u.Email, "@") {
                return u, fmt.Errorf("invalid email format: %s", u.Email)
            }
            if len(u.Password) < 8 {
                return u, errors.New("password must be at least 8 characters")
            }
            if u.Age < 13 || u.Age > 120 {
                return u, fmt.Errorf("age must be between 13 and 120, got %d", u.Age)
            }
            return u, nil
        }),

        // 3. Business rules
        pipz.Apply(BusinessRulesID, func(ctx context.Context, u User) (User, error) {
            // Age restrictions by country
            minAge := getMinAgeForCountry(u.Country)
            if u.Age < minAge {
                return u, fmt.Errorf("minimum age for %s is %d", u.Country, minAge)
            }

            // Referral validation
            if u.Referrer != "" && !isValidReferrer(u.Referrer) {
                return u, fmt.Errorf("invalid referrer code: %s", u.Referrer)
            }

            return u, nil
        }),

        // 4. Uniqueness check (external service)
        pipz.Apply(UniquenessID, func(ctx context.Context, u User) (User, error) {
            exists, err := database.UserExists(ctx, u.Email)
            if err != nil {
                return u, fmt.Errorf("failed to check uniqueness: %w", err)
            }
            if exists {
                return u, fmt.Errorf("email already registered: %s", u.Email)
            }
            return u, nil
        }),

        // 5. Optional enrichment (doesn't fail pipeline)
        pipz.Enrich(RiskScoreID, func(ctx context.Context, u User) (User, error) {
            score, err := riskEngine.Calculate(ctx, u)
            if err != nil {
                // Log but don't fail
                log.Printf("Failed to calculate risk score: %v", err)
                u.Score = 0.5 // Default medium risk
                return u, err
            }
            u.Score = score
            return u, nil
        }),

        // 6. Data normalization
        pipz.Transform(NormalizeID, func(ctx context.Context, u User) User {
            u.Email = strings.ToLower(strings.TrimSpace(u.Email))
            u.Country = strings.ToUpper(u.Country)
            return u
        }),

        // 7. Audit logging (side effect)
        pipz.Effect(AuditID, func(ctx context.Context, u User) error {
            return auditLog.Record(ctx, "user.validated", map[string]interface{}{
                "email":    u.Email,
                "country":  u.Country,
                "age":      u.Age,
                "score":    u.Score,
            })
        }),
    )
}
```

## Validation Strategies

### Fast-Fail vs Complete Validation

```go
// Define validation identities
var (
    FastFailID = pipz.NewIdentity("fast-fail", "Validates data, stopping at first error")
    CompleteID = pipz.NewIdentity("complete", "Collects all validation errors")
)

// Fast-fail: Stop at first error (default)
fastFail := pipz.NewSequence[Data](FastFailID,
    validateStep1, // Stops here if fails
    validateStep2,
    validateStep3,
)

// Complete validation: Collect all errors
type ValidationResult struct {
    Data   Data
    Errors []error
}

completeValidation := pipz.Apply(CompleteID, func(ctx context.Context, d Data) (ValidationResult, error) {
    result := ValidationResult{Data: d}

    // Run all validations
    if err := validateField1(d); err != nil {
        result.Errors = append(result.Errors, err)
    }
    if err := validateField2(d); err != nil {
        result.Errors = append(result.Errors, err)
    }
    if err := validateField3(d); err != nil {
        result.Errors = append(result.Errors, err)
    }

    if len(result.Errors) > 0 {
        return result, fmt.Errorf("%d validation errors", len(result.Errors))
    }
    return result, nil
})
```

### Conditional Validation

```go
// Define conditional validation identities
var (
    OrderValidationID    = pipz.NewIdentity("order-validation", "Validates orders with conditional rules")
    BaseValidationID     = pipz.NewIdentity("base-validation", "Validates base order fields")
    PremiumOnlyID        = pipz.NewIdentity("premium-only", "Validates premium features for premium customers")
    PremiumValidationID  = pipz.NewIdentity("premium-validation", "Validates premium-only features")
    PaymentValidationID  = pipz.NewIdentity("payment-validation", "Routes validation by payment method")
)

conditionalValidation := pipz.NewSequence[Order](OrderValidationID,
    // Always validate
    pipz.Apply(BaseValidationID, validateOrderBase),

    // Only validate premium features for premium customers
    pipz.Filter(PremiumOnlyID,
        func(ctx context.Context, o Order) bool {
            return o.Customer.Tier == "premium"
        },
        pipz.Apply(PremiumValidationID, validatePremiumFeatures),
    ),

    // Different validation for different payment methods
    pipz.NewSwitch[Order](PaymentValidationID,
        func(ctx context.Context, o Order) string {
            return o.PaymentMethod
        },
    ).
    AddRoute("credit_card", validateCreditCard).
    AddRoute("paypal", validatePayPal).
    AddRoute("crypto", validateCrypto),
)
```

## Complex Validation Patterns

### Nested Object Validation

```go
// Validate nested structures
type Order struct {
    ID       string
    Customer Customer
    Items    []Item
    Payment  Payment
}

// Define nested validation identities
var (
    NestedOrderID   = pipz.NewIdentity("order", "Validates order and nested structures")
    OrderBaseID     = pipz.NewIdentity("order-base", "Validates order base fields")
    CustomerID      = pipz.NewIdentity("customer", "Validates customer data")
    ItemsID         = pipz.NewIdentity("items", "Validates all order items")
)

orderValidation := pipz.NewSequence[Order](NestedOrderID,
    // Validate order itself
    pipz.Apply(OrderBaseID, validateOrderFields),

    // Validate nested customer
    pipz.Apply(CustomerID, func(ctx context.Context, o Order) (Order, error) {
        validatedCustomer, err := customerValidator.Process(ctx, o.Customer)
        if err != nil {
            return o, fmt.Errorf("invalid customer: %w", err)
        }
        o.Customer = validatedCustomer
        return o, nil
    }),

    // Validate each item
    pipz.Apply(ItemsID, func(ctx context.Context, o Order) (Order, error) {
        for i, item := range o.Items {
            validatedItem, err := itemValidator.Process(ctx, item)
            if err != nil {
                return o, fmt.Errorf("invalid item at index %d: %w", i, err)
            }
            o.Items[i] = validatedItem
        }
        return o, nil
    }),
)
```

### Cross-Field Validation

```go
// Define cross-field validation identity
var (
    CrossFieldID = pipz.NewIdentity("cross-field", "Validates relationships between fields")
)

crossFieldValidation := pipz.Apply(CrossFieldID, func(ctx context.Context, form Form) (Form, error) {
    // Date range validation
    if form.StartDate.After(form.EndDate) {
        return form, errors.New("start date must be before end date")
    }

    // Conditional requirements
    if form.ShippingMethod == "express" && form.Address.Country != "US" {
        return form, errors.New("express shipping only available in US")
    }

    // Sum validation
    var total float64
    for _, item := range form.Items {
        total += item.Price * float64(item.Quantity)
    }
    if math.Abs(total-form.Total) > 0.01 {
        return form, fmt.Errorf("total mismatch: calculated %.2f, provided %.2f", total, form.Total)
    }

    return form, nil
})
```

## Testing Validation

```go
func TestUserValidation(t *testing.T) {
    validator := createUserValidationPipeline()

    tests := []struct {
        name    string
        user    User
        wantErr string
    }{
        {
            name:    "missing email",
            user:    User{Password: "pass123", Age: 25},
            wantErr: "email is required",
        },
        {
            name:    "invalid email format",
            user:    User{Email: "notanemail", Password: "pass123", Age: 25},
            wantErr: "invalid email format",
        },
        {
            name:    "password too short",
            user:    User{Email: "test@example.com", Password: "short", Age: 25},
            wantErr: "at least 8 characters",
        },
        {
            name: "valid user",
            user: User{
                Email:    "test@example.com",
                Password: "securepass123",
                Age:      25,
                Country:  "US",
            },
            wantErr: "",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            _, err := validator.Process(context.Background(), tt.user)
            if tt.wantErr == "" {
                assert.NoError(t, err)
            } else {
                assert.Contains(t, err.Error(), tt.wantErr)
            }
        })
    }
}
```

## Error Reporting

```go
// User-friendly error messages
type ValidationError struct {
    Field   string `json:"field"`
    Message string `json:"message"`
    Code    string `json:"code"`
}

// Define API validation identities
var (
    APIValidationID = pipz.NewIdentity("api-validation", "Validates API requests with user-friendly errors")
    FormatErrorsID  = pipz.NewIdentity("format-errors", "Formats validation errors for API response")
)

func createAPIValidation() pipz.Chainable[Request] {
    return pipz.NewHandle(APIValidationID,
        validationPipeline,
        pipz.Apply(FormatErrorsID, func(ctx context.Context, err *pipz.Error[Request]) (*pipz.Error[Request], error) {
            // Transform technical errors to user-friendly format
            userError := ValidationError{
                Field:   extractField(err.Stage),
                Message: userFriendlyMessage(err.Cause),
                Code:    errorCode(err.Cause),
            }

            // Return as JSON response
            response.JSON(400, userError)
            return err, nil
        }),
    )
}
```

## Performance Optimization

```go
// Define performance optimization identities
var (
    OptimizedID       = pipz.NewIdentity("optimized", "Optimizes validation with parallel checks")
    QuickChecksID     = pipz.NewIdentity("quick-checks", "Performs quick local validation")
    ExternalChecksID  = pipz.NewIdentity("external-checks", "Runs external validations in parallel")
    GeoValidationID   = pipz.NewIdentity("geo-validation", "Validates geographic location")
    RiskAssessmentID  = pipz.NewIdentity("risk-assessment", "Assesses user risk profile")
    CreditCheckID     = pipz.NewIdentity("credit-check", "Performs credit verification")
    FinalCheckID      = pipz.NewIdentity("final-check", "Final validation using enriched data")
)

// Parallel validation for independent checks
parallelValidation := pipz.NewSequence[User](OptimizedID,
    // Quick local validations first
    pipz.Apply(QuickChecksID, quickLocalValidation),

    // Expensive external validations in parallel
    pipz.NewConcurrent[User](ExternalChecksID,
        pipz.Enrich(GeoValidationID, validateGeoLocation),
        pipz.Enrich(RiskAssessmentID, assessRisk),
        pipz.Enrich(CreditCheckID, checkCredit),
    ),

    // Final validation based on enriched data
    pipz.Apply(FinalCheckID, finalValidation),
)
```

## See Also

- [Apply Reference](../5.reference/3.processors/apply.md)
- [Enrich Reference](../5.reference/3.processors/enrich.md)
- [Filter Reference](../5.reference/4.connectors/filter.md)
- [Testing Guide](../3.guides/6.testing.md)
